# 一、C++

## 1.1类型转换操作符

`static_cast`

- **用途**：用于编译时的类型转换，比如基本数据类型的转换（int到float等），以及向上（子类到基类）或向下（基类到子类，但不涉及多态）的类层次结构转换。
- **安全性**：相对安全，因为它不允许两个无关类型之间的转换，但不执行运行时类型检查。
- **示例**：将`float`转换为`int`，或者将基类指针转换为派生类指针（当确定转换是安全的时候）。
- 基本数据类型可以任意转换，基类和子类指针也可以互相转换，但是不能用于不同类型的转换

`dynamic_cast`

- **用途**：主要用于对象的安全向下转换（基类指针或引用转换为派生类指针或引用），并在运行时检查类型的有效性。只能用于含有虚函数的类之间的转换。
- **安全性**：相对安全，因为它在运行时检查转换的有效性。如果转换失败（例如，试图将基类指针转换为并非实际类型的派生类指针），则会返回nullptr（对于指针）或抛出异常（对于引用）。
- **示例**：在多态基类和派生类之间进行类型转换时，检查是否安全转换。
- 将基类指针转换为派生类指针，前提是转换的基类指针本身初始化时就是以new的派生类，不然会转换失败

`reinterpret_cast`

- **用途**：用于低层次的类型转换，可以将任何指针类型转换为任何其他指针类型（包括不相关的类型），也可以将指针类型转换为足够大的整型，反之亦然。
- **安全性**：非常不安全，因为它允许几乎任意的转换，不检查语义，使用时需要非常小心。
- **示例**：将指针转换为整数，或者将函数指针转换为另一种类型的函数指针。
- 和c风格的强制转换一样，可以执行任意类型的转换

`const_cast`

- **用途**：用于移除或添加对象的`const`属性（或`volatile`属性）。这通常用于指向常量的指针或引用，使之能够修改其指向的数据。
- **安全性**：使用时需要小心，因为移除`const`属性并修改数据可能会导致未定义行为，特别是如果原始对象本身是一个常量。
- **示例**：将指向常量的指针转换为指向非常量的指针，以便修改其指向的数据，但前提是知道这样做是安全的

## 1.2.智能指针

### 1.2.1 `unique_ptr`

unique_ptr的实现原理核心就是：**它对于资源是独占的，对于同一块内存只能有一个持有者**，也就是不能放在等号的右边。Unique_ptr会在栈上分配，当离开作用域后，删除里面持有的资源对象。禁用拷贝构造和拷贝赋值即可

```c++
#include <algorithm> // std::swap
template<typename T>
class UniquePtr {
public:
    // 默认构造函数
    UniquePtr() : ptr(nullptr) {}
    // 通过裸指针构造
    explicit UniquePtr(T* p) : ptr(p) {}
    // 移动构造函数
    UniquePtr(UniquePtr&& other) noexcept : ptr(other.ptr) {
        other.ptr = nullptr;
    }
    // 禁用拷贝构造函数
    UniquePtr(const UniquePtr&) = delete;
    // 移动赋值运算符
    UniquePtr& operator=(UniquePtr&& other) noexcept {
        if (this != &other) {
            delete ptr; // 删除当前对象拥有的资源
            ptr = other.ptr; // 转移资源所有权
            other.ptr = nullptr; // 清除源对象的资源所有权
        }
        return *this;
    }
    // 禁用拷贝赋值运算符
    UniquePtr& operator=(const UniquePtr&) = delete;
    // 解引用运算符
    T& operator*() const {
        return *ptr;
    }
    // 成员访问运算符
    T* operator->() const {
        return ptr;
    }
    // 获取裸指针
    T* get() const {
        return ptr;
    }
    // 释放所有权并返回裸指针
    T* release() {
        T* temp = ptr;
        ptr = nullptr;
        return temp;
    }
    // 重置指针
    void reset(T* p = nullptr) {
        T* old = ptr;
        ptr = p;
        if (old) {
            delete old;
        }
    }
    // 析构函数
    ~UniquePtr() {
        delete ptr;
    }
private:
    T* ptr; // 持有的对象指针
};

```

### 1.2.2 `shared_ptr`

`shared_ptr`共享对象的所有权，但性能略差

- 当进行**构造函数**操作时，创建一个智能指针的新的对象的时候，指针被初始化，内部的引用计数的值设置为1。
- 当进行**拷贝构造**操作时，指针会指向被赋值的指针，并且会对它们指向的资源的引用计数加1。
- 当进行**赋值构造**操作时，会先使赋值前资源的引用计数减1，如果减1后计数为0了，那么就要去释放这个资源。然后进行指针的赋值操作，然后对赋值后的新的资源的引用计数加1
- 当进行**析构操作**时，会先使引用计数的值减1，如果计数等于0了，那么就去释放资源。

```c++
template <typename T> class RefPtr
{
private:
    friend class MySharedPtr<T>;
    RefPtr(T *ptr) :p(ptr), count(1)
    {}
    ~RefPtr()
    {
        delete p;
    }
    int count;
    T *p;
};

template <typename T> class MySharedPtr
{
public:
    MySharedPtr(T *ptr) :rp(new RefPtr<T>(ptr))
    {}
    MySharedPtr(const SmartPtr<T> &sp) :rp(sp.rp) //拷贝构造
    {
        ++rp->count;
    }

    SmartPtr& operator=(const SmartPtr<T>& rhs)
    {
        ++rhs.rp->count;        //然后将引用计数减1，可以应对自赋值
            delete rp;
        rp = rhs.rp;
        return *this;
    }
    T & operator *()
    {
        return *(rp->p);
    }
    T* operator ->()
    {
        return rp->p;
    }
    ~MySharedPtr() //在SharedPtr析构时会去将引用计数-1 ，如果引用计数为0，则删除持有的指针
    {
        if (--rp->count == 0)   
        {
            delete rp;
        }
        else
        {
            cout << "还有" << rp->count << "个指针指向基础对象" << endl;
        }
    }
private:
    RefPtr<T> *rp; 
};
```

### 1.2.3 `weak_ptr`

`weak_ptr`配合`shared_ptr`，解决循环引用的问题

## 1.3 多态的实现

### 1.3.1 动态多态

何为动态多态：通过父类指针指向子类对象去执行子类重载的虚函数，每个含有虚函数的类都会有包含有一个虚函数表，这个虚函数表种存储了虚函数的调用地址

**C++的编译器保证虚函数表的指针存在于对象实例中最前面的位置**，这样通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。

虚函数表是存放在全局的只读数据段： `.rodata` ,  **一个类只能有一个虚函数表，无论这个类有多少个实例**

```c++
class A {
public:
    virtual void a() { cout << "A a()" << endl; }
    virtual void b() { cout << "A b()" << endl; }
    virtual void c() { cout << "A c()" << endl; }
    int x, y;
};

class B :public A {
public:
    int z;
    virtual void b() { cout << "B b()" << endl; }
};
```

<img src="image/image-20240216225534136.png" alt="image-20240216225534136" style="zoom:67%;" />

上面的内存模型应该是这样子：

```c++
A* a1 = new A();
A* a2 = new A();
A* a3 = new B();
A* a4 = new B();
```

**基类的虚函数表和子类的虚函数表不是同一个表**，这是在编译器确定的；`ClassB`继承与`ClassA`，其虚函数表是在`ClassA`虚函数表的基础上有所改动的，变化的仅仅是在子类中重写的虚函数。如果子类没有重写任何父类虚函数，那么子类的虚函数表和父类的虚函数表在**内容上是一致的**。

在一个子类继承了多个父类的情况下，这个子类继承了多少个父类，子类就会有多少个虚函数指针，前提是基类要有虚函数才算上这个基类

> [C++ 面试必问：深入理解虚函数表 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/616522622)
>
> [虚函数表存储的位置（解析C++内存分配及其编译分段）_c++虚函数存储位置-CSDN博客](https://blog.csdn.net/qq_35683407/article/details/118884877)
>
> [C++虚函数表的位置——从内存的角度 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/563418849)
>
> [C++多态虚函数表详解(多重继承、多继承情况)_一个类有几个虚函数表-CSDN博客](https://blog.csdn.net/qq_36359022/article/details/81870219)

### 1.3.2 静态多态

函数重载 

函数模板

CRTP

## 1.4 右值引用和std::move

## 1.5 内存开辟与删除

### 1.5.1 程序的内存分配

![在这里插入图片描述](image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZ2VsRGc=,size_16,color_FFFFFF,t_70.png)

所谓的程序内存其实是一个进程的内存，由于`cpu`的内存分页机制，所以对于每个进程来说都意味着自己能够占据所有的内存空间，其实是个虚拟地址空间，最后都会通过`mmu`映射到实际的物理内存

- **代码区**：放置操作系统相关的代码和数据。（用户不能直接进行操作 ------ 可以通过调用系统提供的 api 函数）
- **数据段**：存储全局变量和静态数据
- **堆区**：用于程序运行时动态内存分配，堆是向上增长的。
- **栈区**：用于存放函数的非静态局部变量、函数返回值、函数参数等，栈是向下增长的；先入后出，由栈指针维护
- **内核空间**：操作系统相关的代码和数据，一般映射到虚拟地址空间的地址最大处

### 1.5.2 malloc 和 free

`malloc`和`free`是c语言的库函数

```c
void* addr = malloc(100);
free(addr);
```

`malloc`有两种分配内存的方式

- 如果用户分配的内存小于`128KB`，则通过`brk()`系统调用申请内存。此种情况下当进程首次调用`malloc`时，`malloc`会像内核申请一块堆区的内存用作一个内存池，将申请到的内存分块，用户需要多大就从这些内存块中拿出一块，当调用`free`函数时，只会将申请到的内存还给`malloc`，而`malloc`申请到的内存不会将从操作系统分配的内存解除映射
- 如果用户分配的内存大于`128KB`，则通过`mmap()`系统调用分配内存。在此种情况下调用`free`函数，用于是直接通过`mmap`向操作系统拿到的映射内存，此时会直接调用`ummap`解除映射，从而将申请到的内存直接还给操作系统
- 不同的`glibc`中定义的阈值是不一样的
- `free`空指针不会造成崩溃，在`free`函数内部会检测传入的地址是否为空

> malloc 和 free 的原理：
>
> [malloc系列问题5-1：free函数是如何知道要释放多少内存的？ 走读glibc free函数_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1PC4y1d7Y9/?spm_id_from=333.788&vd_source=1325a6af2d360c06e8e0c5e177802b1b)
>
>  [malloc系列问题5-2：free函数是如何知道要释放多少内存的？ 走读glibc free函数_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1h34y137xJ/?spm_id_from=333.788&vd_source=1325a6af2d360c06e8e0c5e177802b1b)

除了`malloc`之外，`c`语言分配内存的函数还有

- `calloc`：只进行空间申请+零初始化
- `realloc`：如果传入的第一个参数为`nullptr`，功能等价于`malloc`；否则调整空间大小：a.直接原地调整大小 b.重新开空间，内容拷贝，释放原空间

### 1.5.3 new 和 delete

new和delete是c++的操作符，内部的操作如下：

> operator new 和 operator delete是系统提供的全局函数，new和delete会去调用

当new和delete操作基本类型时：

- new：operator new ---> malloc
- delete: operator delete ----> free
- delete [ ]: operator delete [ ] ----> operator delete --->free

当new和delete操作自定义类型时：

- new：operator new ----> malloc ---> 构造函数 ；  在为此对象申请内存后，调用此对象的构造函数
- delete：析构函数 ----> operator delete ----> free;  在delete时是先执行该对象的析构函数，然后释放掉此内存
- new []：operator new[] ----> operator new ----> malloc -----> N次构造函数
- delete []：N次析构函数----> operator delete[] ----> operator delete  ----->free


> [C/C++——new和delete的实现原理（详解）_delete[\]的实现原理-CSDN博客](https://blog.csdn.net/qq_45657288/article/details/114699235)

## 1.6 原子操作和内存模型

### 1.6.1 原子操作

原子变量是一种多线程编程种常用的同步机制。用于确保在多线程操作时对共享变量的操作在执行时不会被其他线程的操作干扰。原子变量具有原子性，对原子变量的读写要么全部一次性完成，要么全部未完成

- `std::atomic<T>`

- `is_lock_free`：是`atomic`的成员函数，用来检查此类型是否支持原子操作

- `load(std::memory_order order)`：获取当前原子变量的值

- `store(T desired,std::memory_order order)`：将指定的值写入到原子变量中

- `exchange(T new_value, std::memory_order order)`：原子地将一个原子变量的值设置为新值，并返回变量的旧值。

- `compare_exchange_weak`：

  ```
  bool compare_exchange_weak(T& expected, T desired, std::memory_order success, std::memory_order failure);
  bool compare_exchange_weak(T& expected, T desired, std::memory_order order = std::memory_order_seq_cst);
  ```

  - 函数尝试以原子方式比较原子对象的值与提供的期望值（expected value），如果这两个值相等，它就将原子对象的值设置为所提供的新值（desired value）。如果原子对象的值与期望值不相等，操作失败，`expected` 将被更新为原子变量的当前值。
  - `success` 和 `failure` 指定了在操作成功或失败时的内存顺序。如果只提供了一个 `order` 参数，它将同时用于操作成功和失败的情况。
  - 这是一个弱化版的原子操作函数，因为在某些平台上它可能会失败并重试，如果需要严格的保证原子性，应该使用`compare_exchange_strong`函数。
  - `compare_exchange_strong`函数和`compare_exchange_weak`用法一样
  - `while` + `compare_exchange_weak` 实现自旋操作

- `fetch_add`：原子加
- `fetch_sub`：原子减
- `fetch_and`：原子与
- `fectch_or`：原子或
- `fetch_xor`：原子异或


> [std::atomic::compare_exchange_weak, std::atomic::compare_exchange_strong - C++中文 - API参考文档 (apiref.com)](https://www.apiref.com/cpp-zh/cpp/atomic/atomic/compare_exchange.html)

### 1.6.2 内存模型

**缓存一致性：**

- [一小时，完全搞懂 cpu 缓存一致性 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/651732241)
- 缓存一致性问题主要是为了解决在多处理器系统中，每个处理器都可能有自己的缓存，而这些处理器又可能同时访问和修改共享数据的情况下，如何保持缓存之间数据的一致性。缓存一致性的核心问题是确保在任何时刻，任何处理器上的缓存读取到的共享数据是最新的，即所有处理器对共享数据的修改都能被其他处理器感知到。

**为什么需要锁：**

- [08 | 锁：并发操作中，解决数据同步的四种方法 (geekbang.org)](https://time.geekbang.org/column/article/377913)

- 对于单核`cpu`，在多线程中，假设两个线程同时操作一片共享区，其中一个线程在对一个变量或者内存执行写操作时，还没有将数据写入到`cache`中，但是此时由于线程切换，此线程被打断，另外一个线程也对这个变量执行写操作，并且数据写入到`cache`中了，此时切换回第一个线程，第一个线程将会把修改后的数据写入`cache`，这样第二个线程做的写操作就被忽略了，这样就导致了竞态问题
- 对于多核`cpu`，在多线程中，假设多核同时访问同一个共享变量，此变量在多核的缓存中都存在，如果其中一个核心修改了此变量而没有同步就会造成竞态。

**原子性如何实现：**

- cpu提供了一些原子性的指令

- 何为原子性：

  - Q:：假设我现在cpu中有两个核心，这两个核心上分别运行着两个线程，这两个线程都会去对一个int变量 i执行+1的操作，cpu会通过cpu的缓存一致性原则来保证 +1的操作是原子的吗？

  - A：原子操作是指在多线程环境中，一个操作要么完全执行，要么完全不执行，且操作过程中不会被其他线程中断。在你的例子中，两个线程对同一个变量执行+1操作，这个操作通常包括三个步骤：

    1. 读取变量i的当前值。
    2. 计算新值（即当前值+1）。
    3. 写回新值到变量i。

    即使缓存一致性机制能保证每个步骤看到的是最新的数据，但这三个步骤作为一个整体并不是原子的。如果两个线程几乎同时执行这些操作，它们可能会读取到变量i相同的初始值，分别计算出新值，并写回，导致实际上的增加操作只执行了一次而不是两次。

- 如何解决：通过cpu加偶提供的lock指定对指定内存进行锁定

  - **总线锁**：LOCK#信号就是总线锁，当一个处理器往总线上输出LOCK#信号时，其它处理器的请求将被阻塞，此时该处理器独占共享内存。总线锁这种做法锁定的范围太大了，导致CPU利用率急剧下降。
  - **缓存锁**：如果访问的内存区域已经缓存在处理器的缓存行中，P6系统和之后系列的处理器则不会声明LOCK#信号，它会对CPU的缓存中的缓存行进行锁定，在锁定期间，其它 CPU 不能同时缓存此数据，在修改之后，通过`缓存一致性`协议来保证修改的原子性，这个操作被称为“缓存锁”
  - 在CPU的LOCK信号被声明之后，在此期随同执行的指令会转换成原子指令。在多处理器环境中，LOCK信号确保，在此信号被声明之后，处理器独占使用任何共享内存。 核心意思主要说明LOCK指令在声明之后通过锁定总线，独占共享内存，通过一种排它的思想确保当前对内存操作的只有一个线程，然后确定在这段声明期间指令执行不会被打断，来保证其原子性。当使用 LOCK 指令前缀时，它会使 CPU 宣告一个 LOCK# 信号，这样就能确保在多处理器系统或多线程竞争的环境下互斥地使用这个内存地址。
  - 多核体系的原子操作就是通过缓存锁来实现的

**为什么会产生内存序的问题：**

- **cpu指令重排：**上面到在多核情况下，其中一个核心通过缓存锁实现了对一个内存的原子访问，其他核心不能去访问此内存，但是，cpu为了最大化的利用效率，可以去执行与此内存无关的后续的其他指令，产生了cpu层面的乱序执行
- **编译器优化指令重排**：编译器在编译一段业务代码时，可能会在汇编层面调整代码的运行顺序

- 因此为了能够指导编译器或者cpu对代码的执行顺序问题，因此有了内存序，内存序用于指导编译器和cpu如何去编排指令顺序
- 内存序规定了多个线程访问同一个内存地址的语义；
  - 某个线程对内存地址的更新何时能被其他线程看到 - 可见性
  - 某个线程对内存地址的访问附近可以做怎么样的优化 - 顺序性

对于原子类型上的每一种操作，我们都可以提供额外的参数，从枚举类std::memory_order取值，用于设定所需的内存次序语义（memory-ordering semantics）。

- `std::memory_order_relaxed`：**松散内存序**，不干涉指令重排，随便cpu和编译器对指令进行重排

  ![image-20240225234927006](image/image-20240225234927006.png)

- `std::memory_order_release`：**释放操作**，对应原子写操作，允许后面指令重排到写入x之前，但是不允许写入x之前的读写指令重排到写入x之后；**在运行本行代码之前，如果有任何读写内存的操作，都是不能放到本行语句之后的。**

  ![image-20240225235024070](image/image-20240225235024070.png)

  ![image-20240225235901227](image/image-20240225235901227.png)

- `std:: memory_order_acquire`：**获得操作**，对应原子读操作；意思是读取x时，后续的读写操作都不能重排到此次读之前，但是读之前的指令可以重排到此次读之后

  ![image-20240225235135686](image/image-20240225235135686.png)

- `std::memory_order_consume`

- `std::memory_order_acq_rel`：**获得释放语义**：既有写又有读的情况`写不后 && 读不前`

- `std::memory_order_seq_cst`：**顺序一致性语义**：不允许指令重排

> [C++ atomic详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/463913671)
>
> [C++ 原子操作（原子操作以及接口、原子性实现、内存序、读线程安全）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1pe411Z7AT/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=1325a6af2d360c06e8e0c5e177802b1b)
>
> [std::memory_order - cppreference.com](https://zh.cppreference.com/w/cpp/atomic/memory_order)
>
> [c++并发编程1.内存序 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/55901945)

## 1.7 多线程



## 1.8 其他

### 1.8.1 **C++模板类的声明和定义都要放在.h文件中**

- **编译过程**：编译器在编译代码时是一个个`.cpp`文件编译，此`cpp`文件包含的头文件的内容会被复制到`cpp`中，编译器编译完毕一个`cpp`，就会生成一个`.obj`文件，然后链接器将所有的`.obj`文件链接在一起
- **链接过程**：假设在一个`.cpp`文件中调用了这个函数，这个函数并没有在此`cpp`文件中实现而在包含的头文件中声明了，这样链接器就会认为此函数是实现在其他的`cpp`文件里了，从而在链接的过程中将此函数的实现链接过来

- **模板特性**：模板是只有在实例化的时候才会被编译成二进制代码，因为如果不调用它，那么不知道这个模板长什么样子。当编译器看到模板的声明时，并不能实例化出来模板的代码，只能**创建一个外部链接符号并期待链接器能找**到；现在假设一个模板类的声明和实现是分别在头文件和源文件中进行

  ```c++
  \\ ------- in Test.h start
  #ifndef TEST_H
  #define TEST_H
  template <typename T>
  class Test
  {
  public:
      Test(T v)
          : t (v)
      {}
      void testOutput();
  private:
      T t;
  };
   
  #endif // TEST_H
  \\ ------- in Test.h end
   
  \\ ------- in Test.cpp start
  #include "Test.h"
  #include <QDebug>
  template<typename T>
  void Test<T>::testOutput()
  {
      qDebug() << "This is a test output: " << t;
  }
  \\ ------- in Test.cpp end
   
  \\ ------- in main.cpp start
  #include <QCoreApplication>
  #include "ZDS/Test.h"
   
  int main(int argc, char *argv[])
  {
      QCoreApplication a(argc, argv);
   
      Test<int> test(13);
      test.testOutput(); // #1
   
      return a.exec();
  }
  \\ ------- in main.cpp end
  ```

  在`main.cpp`中实例化了一个`Test<int>`类型的类，此时`main.cpp`中会去调用`test.testOutput();`，但是链接器会报如下的错误;

  ```c++
  main.obj:-1: error: LNK2019: 无法解析的外部符号 "public: void __thiscall Test<int>::testOutput(void)" (?testOutput@?$Test@H@@QAEXXZ)，该符号在函数 _main 中被引用
  ```

  编译器在#1处并不知道` Test<int>::testOutput `的定义，因为它不在 `Test.h` 里面，于是编译器只好寄希望于连接器，希望它能够在其他 `.obj `里面找到 `Test<int>::testOutput` 的实例，在本例中就是 `Test.obj`，然而，后者中真有 `Test<int>::testOutput` 的二进制代码吗？NO！！！因为 C++ 标准明确表示，当一个模板不被用到的时侯它就不该被实例化出来，`Test.cpp `中用到了` Test<int>::testOutput `了吗？没有！！所以实际上 `Test.cpp `编译出来的 `Test.obj `文件中关于` Test<int>::testOutput` 一行二进制代码也没有，于是连接器就傻眼了，只好给出一个连接错误。

  但如果在`Test.cpp`中写一个函数调用`Test<int>::testOutput`，编译器就会在`Test.cpp`文件中实例化出该函数，这样`Test.obj`中就有了`Test<int>::testOutput`的地址，链接器才能够连接上。


> [C++模板类的声明和定义都要放在.h文件中_c++ 模板类 函数定义 h文件-CSDN博客](https://blog.csdn.net/RolleX/article/details/131841267?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-131841267-blog-109109110.235^v43^pc_blog_bottom_relevance_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-131841267-blog-109109110.235^v43^pc_blog_bottom_relevance_base1&utm_relevant_index=5)

### 1.8.2 指针和引用的区别

- 指针存放某个对象的地址，其本身就是一个变量，本身就有地址，所以可以有指向指针的指针；可变，包括其所指向的地址的改变和其指向的地址中所存放数据的改变
- 引用是变量的别名，不可变必须初始化，从底层实现来说，引用也是一个变量，这个变量中存放的是一个指针，只不过这个变量是不可修改的，可以被认为是一个`const`的指针，在用户语言层面编译器使得引用呈现出引用的特性
- 不存在指向空值的引用，但是存在指向空值的指针

> [c++中“引用”的底层实现原理详解_c++引用的底层原理-CSDN博客](https://blog.csdn.net/lws123253/article/details/80353197)

# 二、数据结构/STL

## 2.1 pair 容器

```c++
namespace std{
	template <typename T1, typename T2>
    struct pair{
        T1 first;
        T2 second;
    }
}
```

## 2.2 vector 容器

动态数组

## 2.3 list 容器

双向链表

## 2.4 deque容器

## 2.5 stack && queue

## 2.6 map && set

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |



# 三、设计模式

## 3.1 单例模式

## 3.2 工厂模式

## 3.3 观察者模式

# 四、网络

# 五、操作系统 

# 六、工具链

## 6.1 Git

## 6.2 GDB

## 6.3 Cmake/Makefile



# 六、项目



